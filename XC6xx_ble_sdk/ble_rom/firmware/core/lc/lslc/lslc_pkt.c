/************************************************************************
 * MODULE NAME:    lslc_pkt.c
 * PROJECT CODE:   BlueStream
 * DESCRIPTION:    LSLC_Packet
 * MAINTAINER:     John Nelson
 * CREATION DATE:  12 Jun 1999
 *
 * SOURCE CONTROL: $Id: lslc_pkt.c,v 1.124 2013/04/08 11:04:41 tomk Exp $
 *
 * LICENSE:
 *     This source code is copyright (c) 1999-2004 Ceva Inc.
 *     All rights reserved.
 *
 * ISSUES:
 *    The separation of packet generation into distinct functions is to 
 *    improve readability and initial debugging.
 *
 * NOTES TO USERS:
 *    The transmit packets are only generated by the appropriate function,
 *    but the transmit must later be enabled.
 * V2.01   20 Mar 2000         Complete rewrite for new LC scheduler
 ************************************************************************/
#include "sys_config.h"
#include "sys_types.h"
#include "lc_types.h"
#include "lc_interface.h"

#include "hw_lc.h"
#include "dl_dev.h"
#include "lslc_access.h"
#include "lslc_freq.h"
#include "lslc_pkt.h"
#include "lslc_stat.h"

#include "bt_test.h"

#include "lmp_sco_container.h"

#include "lmp_config.h"
#ifndef BLUETOOTH_MODE_LE_ONLY
/*
 * Private functions to this module
 */
static void _LSLCpkt_Prepare_Piconet_Channel_Access(
   const t_devicelink *p_dev_link, t_frame_pos frame_position,
   t_state context);
#endif//BLUETOOTH_MODE_LE_ONLY

/*
 * Private State information
 *
 * Reference to active device link for receiver.
 * Set on Prepare Receive
 * Used on Process Rx Header, Process Rx Packet
 */
/*static*/ t_devicelink *LSLCpkt_Active_Rx_Device_Link_Ref;
/*static*/ t_devicelink *LSLCpkt_Active_Tx_Device_Link_Ref;
u_int8  eSCO_count=0;
u_int8 	EIR_Packet=0;

#if (PRH_BS_DBG_LC_LSLC_PKT==1)
/*
 * Note that each time the stack is stopped for debug this will increment
 */
u_int32   LSLCpkt_Device_Link_Refs_is_Invalid=0;
#endif

/************************************************************************
 *
 * Receiver Specific Functions
 *
 ************************************************************************/

/************************************************************************
 * LSLCpkt_Disable_Receiver
 *
 * Disables receiver, and ensures that no receive will be allowed
 ************************************************************************/
void LSLCpkt_Disable_Receiver(void)
{
    LSLCpkt_Active_Rx_Device_Link_Ref = 0;
    LSLCacc_Disable_Receiver();
}

#ifndef BLUETOOTH_MODE_LE_ONLY
/************************************************************************
 * LSLCpkt_Prepare_Receiver_ID
 *
 * p_dev_link             pointer to active Device Link
 * context                context for activation
 * Determine frequencies and set correlator to syncword to receive ID.
 ************************************************************************/
void LSLCpkt_Prepare_Receiver_ID(const t_devicelink *p_dev_link, t_state context)
{
    LSLCfreq_Prepare_Frequency_Context(p_dev_link, RX_START, context);

    LSLCacc_Prepare_Rx_ID(context);
    
    /*
     * Appropriate syncword is always in Device Link
     */
    LSLCacc_Build_AccessCode(DL_Get_Access_Syncword_Ref(p_dev_link));
    LSLCpkt_Active_Rx_Device_Link_Ref = (t_devicelink *) p_dev_link;
}


/************************************************************************
 * LSLCpkt_Prepare_Receiver_FHS
 *
 * p_dev_link             pointer to active Device Link
 * context                context for activation
 *
 * Determine frequency and set correlator to syncword to receive FHS.
 ************************************************************************/
void LSLCpkt_Prepare_Receiver_FHS(const t_devicelink *p_dev_link, t_state context)
{
    t_uap_lap freq_crc_uap_lap;

    if (context==Inquiry || context==MasterExtendedInquiryResponse)
    {
        /*
         * Always use GIAC for frequency calculation/DCI(=UAP) for CRC.
         */
        freq_crc_uap_lap = ((t_uap_lap) DEFAULT_CHECK_INIT)<<24 | GIAC_LAP;
    }
    else if (context==SlavePageResponse)
    {
        /*
         * Slave responds using its own bd_addr
         */
         freq_crc_uap_lap = DL_Get_UAP_LAP( DL_Get_Local_Device_Ref() );
    }
    else /* Master Slave Switch */
    {
         freq_crc_uap_lap = DL_Get_UAP_LAP( p_dev_link );
    }

    /*
     * FHS receive freq for SlavePageResponse setup early so not required
     * here also, ref LSLCfreq_Early_Prepare_TxRxFreqs_SlavePageResponse.
     */
    if(!((DL_Get_Tx_Packet_Type(p_dev_link)==IDpkt) && (context==SlavePageResponse)))
    {
        LSLCfreq_Prepare_Frequency_Context(p_dev_link, RX_START, context);
    }
    
    LSLCacc_Prepare_Rx_FHS(context, (t_uap) (freq_crc_uap_lap>>24));
    LSLCacc_Build_AccessCode(DL_Get_Access_Syncword_Ref(p_dev_link));
    LSLCpkt_Active_Rx_Device_Link_Ref = (t_devicelink *) p_dev_link;

    /*
     * If you know you are going to receive an FHS, am_addr must be 0
     */
    LSLCacc_Set_Am_Addr(0);
}

/************************************************************************
 * LSLCpkt_Prepare_Receiver_Connection
 *
 * p_dev_link             pointer to active Device Link
 *
 * Determine frequency and set correlator to syncword to receive packet
 * on Piconet Channel Connection.
 * SCO preparation is implicitly handled here.
 *
 * Valid Packets are: POLL, NULL, ACL, SCO or FHS for M/S switch
 ************************************************************************/
void LSLCpkt_Prepare_Receiver_Connection(const t_devicelink *p_dev_link)
{
    /*
     * Prepare the frequency, Prepare to Rx and Set Syncword
     */
    _LSLCpkt_Prepare_Piconet_Channel_Access(p_dev_link, RX_START, Connection);

    /*
     * ACL LT_ADDR is always used in setting up the receiver.
     */
    LSLCacc_Set_Am_Addr(DL_Get_Am_Addr(p_dev_link));

    LSLCacc_Prepare_Rx_Connection(p_dev_link);

    LSLCpkt_Active_Rx_Device_Link_Ref = (t_devicelink *) p_dev_link;
}
#endif//BLUETOOTH_MODE_LE_ONLY
#if (PRH_BS_CFG_SYS_LMP_MSS_SUPPORTED==1)
/************************************************************************
 * LSLCpkt_Prepare_Receiver_Master_Slave_Switch
 *
 * p_dev_link             pointer to active Device Link
 *
 * Determine frequency and set correlator to syncword to receive packet
 * on Piconet Channel undergoing role switch
 *
 * Valid Packets are: POLL, NULL, or FHS for M/S switch
 ************************************************************************/
void LSLCpkt_Prepare_Receiver_Master_Slave_Switch(
    const t_devicelink *p_dev_link)
{
    /*
     * Prepare the frequency, Prepare to Rx and Set Syncword
     */
    _LSLCpkt_Prepare_Piconet_Channel_Access(
        p_dev_link, RX_START, Master_Slave_Switch);
    LSLCacc_Set_Am_Addr(DL_Get_Am_Addr(p_dev_link));

    LSLCacc_Prepare_Rx_Connection(p_dev_link);

    LSLCpkt_Active_Rx_Device_Link_Ref = (t_devicelink *) p_dev_link;
}
#endif


#if (PRH_BS_CFG_SYS_RETURN_TO_PICONET_SUPPORTED==1)
  
/************************************************************************
 * LSLCpkt_Prepare_Receiver_Return_To_Piconet
 *
 * p_dev_link             pointer to active Device Link
 * rx_freq_clk              bt clock to use for freq of search window
 *
 * Determine frequency and set correlator to syncword to receive packet
 * on Piconet Channel Connection.
 * Valid Packets are: POLL, NULL, ACL, SCO 
 ************************************************************************/
void LSLCpkt_Prepare_Receiver_Return_To_Piconet(
    const t_devicelink *p_dev_link, t_clock rx_freq_clk)
{
    t_encrypt_mode encrypt_mode = DL_Get_Encryption_Mode(p_dev_link);

    LSLCfreq_Prepare_Rx_Frequency_R2P(p_dev_link, rx_freq_clk);

    /*
     * Encryption can be asymmetric Tx Only or Rx Only
     * Following code maps into hardware for each slot, as requested.
     */
    if(encrypt_mode == ENCRYPT_POINT2POINT_BROADCAST)
    {
        encrypt_mode = ENCRYPT_HARDWARE_ONLY_ALL;
    }
    else if(encrypt_mode == ENCRYPT_MASTER_RX_ONLY)
    {
        encrypt_mode = ENCRYPT_NONE;
    }
    else if(encrypt_mode == ENCRYPT_MASTER_TX_ONLY)
    {
        encrypt_mode = ENCRYPT_POINT2POINT;
    }


    if (encrypt_mode != ENCRYPT_NONE)
    {
        LSLCacc_Prepare_Tx_Rx_Encryption(DL_Get_Encryption_Key_Ref(p_dev_link),
                                     DL_Get_Encryption_Key_Length(p_dev_link));
    }

    LSLCacc_Prepare_Tx_Rx_Connection(p_dev_link,
       (t_uap) ((DL_Get_UAP_LAP(p_dev_link)>>24)) /*crc-hec init is uap*/,
       encrypt_mode,
       Return_To_Piconet);

    LSLCacc_Build_AccessCode(DL_Get_Access_Syncword_Ref(p_dev_link));

    LSLCacc_Set_Am_Addr(DL_Get_Am_Addr(p_dev_link));

    LSLCacc_Prepare_Rx_Return_To_Piconet(p_dev_link);

    LSLCpkt_Active_Rx_Device_Link_Ref = (t_devicelink *) p_dev_link;
}

#if (PRH_BS_CFG_SYS_HW_WINDOW_WIDENING_SUPPORTED==1)

/************************************************************************
 * LSLCpkt_Prepare_Receiver_WinExt_Return_To_Piconet
 *
 * p_dev_link             pointer to active Device Link
 * rx_freq_clk              bt clock to use for freq of search window
 *
 * Determine frequency and set correlator to syncword to receive packet
 * on Piconet Channel Connection with Win_Ext instead of Full_Rx.
 ************************************************************************/
 void LSLCpkt_Prepare_Receiver_WinExt_Return_To_Piconet(
		const t_devicelink *p_dev_link, t_clock rx_freq_clk)
{
    t_encrypt_mode encrypt_mode = DL_Get_Encryption_Mode(p_dev_link);

    LSLCfreq_Prepare_Rx_Frequency_R2P(p_dev_link, rx_freq_clk);

    /*
     * Encryption can be asymmetric Tx Only or Rx Only
     * Following code maps into hardware for each slot, as requested.
     */
    if(encrypt_mode == ENCRYPT_POINT2POINT_BROADCAST)
    {
        encrypt_mode = ENCRYPT_HARDWARE_ONLY_ALL;
    }
    else if(encrypt_mode == ENCRYPT_MASTER_RX_ONLY)
    {
        encrypt_mode = ENCRYPT_NONE;
    }
    else if(encrypt_mode == ENCRYPT_MASTER_TX_ONLY)
    {
        encrypt_mode = ENCRYPT_POINT2POINT;
    }


    if (encrypt_mode != ENCRYPT_NONE)
    {
        LSLCacc_Prepare_Tx_Rx_Encryption(DL_Get_Encryption_Key_Ref(p_dev_link),
                                     DL_Get_Encryption_Key_Length(p_dev_link));
    }

    LSLCacc_Prepare_Tx_Rx_Connection(p_dev_link,
       (t_uap) ((DL_Get_UAP_LAP(p_dev_link)>>24)) /*crc-hec init is uap*/,
       encrypt_mode,
       Return_To_Piconet);

    LSLCacc_Build_AccessCode(DL_Get_Access_Syncword_Ref(p_dev_link));

    LSLCacc_Set_Am_Addr(DL_Get_Am_Addr(p_dev_link));

    LSLCacc_Prepare_Rx_Connection(p_dev_link);

    LSLCpkt_Active_Rx_Device_Link_Ref = (t_devicelink *) p_dev_link;
}

#endif

#endif
#ifndef BLUETOOTH_MODE_LE_ONLY
/************************************************************************
 * LSLCpkt_Process_Rx_Packet_Header
 *
 * Process the received packet header for the Active Rx Device Link
 ************************************************************************/
#ifndef REDUCE_ROM 
void LSLCpkt_Process_Rx_Packet_Header(void)
{
    if (LSLCpkt_Active_Rx_Device_Link_Ref)
    {
        LSLCacc_Process_Rx_Header(LSLCpkt_Active_Rx_Device_Link_Ref);
        LSLCacc_Process_RSSI(LSLCpkt_Active_Rx_Device_Link_Ref);
    }
#if (PRH_BS_DBG_LC_LSLC_PKT==1)
    else
    {
        LSLCpkt_Device_Link_Refs_is_Invalid++;
    }
#endif
}
#endif
#endif//BLUETOOTH_MODE_LE_ONLY

/************************************************************************
 * LSLCpkt_Process_No_Rx_Packet
 *
 * Process the no received packet interrupt for the Active Rx Device Link
 ************************************************************************/
#ifndef BLUETOOTH_MODE_LE_ONLY
void LSLCpkt_Process_No_Rx_Packet(void)
{
    if (LSLCpkt_Active_Rx_Device_Link_Ref)
    {
        LSLCacc_Process_No_Rx_Packet(LSLCpkt_Active_Rx_Device_Link_Ref);
    }
#if (PRH_BS_DBG_LC_LSLC_PKT==1)
    else
    {
        LSLCpkt_Device_Link_Refs_is_Invalid++;
    }
#endif     
    LSLCpkt_Active_Rx_Device_Link_Ref = 0;      
}

/************************************************************************
 * LSLCpkt_Process_Rx_Packet
 *
 * p_dev_link             pointer to active Device Link
 ************************************************************************/
void LSLCpkt_Process_Rx_Packet(void)
{

    if (LSLCpkt_Active_Rx_Device_Link_Ref)
    {
        if(HW_get_page()==0)
        {
           LSLCacc_Attempt_RSSI_Read(TRUE); /* Late Read Opportunity */
           LSLCacc_Extract_Packet(LSLCpkt_Active_Rx_Device_Link_Ref);
           LSLCacc_Process_RSSI(LSLCpkt_Active_Rx_Device_Link_Ref);
        }
        else
        {
           DL_Set_Rx_Packet_Type(LSLCpkt_Active_Rx_Device_Link_Ref, IDpkt);
           DL_Set_Rx_Status(LSLCpkt_Active_Rx_Device_Link_Ref, RX_OK);
           LSLCstat_Inc_Rx_Packet_Cntr(IDpkt);
		   LSLCstat_Log_Rx_Final_Status(RX_OK);
           LSLCstat_Inc_Valid_Packet_Cntr();
        }
    }
#if (PRH_BS_DBG_LC_LSLC_PKT==1)
    else
    {
        LSLCpkt_Device_Link_Refs_is_Invalid++;
    }
#endif
    LSLCpkt_Active_Rx_Device_Link_Ref = 0;
}

/************************************************************************
 *
 * Transmitter Specific Functions
 *
 ************************************************************************/


/************************************************************************
 * LSLCpkt_Generate_ID
 *
 * p_dev_link            pointer to active Device Link, syncword is IAC|DAC
 * id_context            Inquiry, Page, PageResponse
 *
 * id_context            p_dev_link
 * ----------            ----------
 * Inquiry/Page          Remote_Device_Link.
 * Page_Scan             Local_Device_Link
 * SlavePageResponse     Local_Device_Link
 *
 ************************************************************************/
void LSLCpkt_Generate_ID(t_devicelink *p_dev_link, t_state id_context)
{
    /*
     * FHS response ID in SlavePageResponse and Master_Slave_Switch are
     * setup early in LSLCfreq_Early_Prepare_Frequency_FHS_Response_ID
     * so not required here. ID response ID in SlavePageRespone also setup
     * early in LSLCfreq_Early_Prepare_TxRxFreqs_SlavePageResponse and so
     * not required here either.
     */
    if( (id_context != SlavePageResponse) &&
       ((id_context != Master_Slave_Switch) || (DL_Get_Rx_Packet_Type(p_dev_link)!=FHSpkt)))
    {
#if (PRH_BS_CFG_SYS_LMP_RSSI_SUPPORTED==1)
#if (PRH_BS_CFG_SYS_INQUIRY_RESPONSE_TX_PWR_SUPPORTED == 1)
		if (id_context == Inquiry )
		{
			HWradio_Set_Tx_Power_Level(g_LM_config_info.inquiry_tx_power_level);
		}
		else
#endif
		{
			HWradio_Set_Tx_Power_Level(DL_Get_Power_Level(p_dev_link));
		}
#endif
        LSLCfreq_Prepare_Frequency_Context(p_dev_link, TX_START, id_context);
    }

    LSLCacc_Prepare_Tx_ID(id_context);
    LSLCacc_Build_AccessCode(DL_Get_Access_Syncword_Ref(p_dev_link));

    LSLCpkt_Active_Tx_Device_Link_Ref = (t_devicelink *) p_dev_link;
}

/************************************************************************
 * LSLCpkt_Generate_NULL
 *
 * p_dev_link             pointer to active Device Link
 ************************************************************************/
void LSLCpkt_Generate_NULL(t_devicelink *p_dev_link)
{
    _LSLCpkt_Prepare_Piconet_Channel_Access(p_dev_link, TX_START, Connection);
    LSLCacc_Build_PacketHeader(p_dev_link, NULLpkt);
    LSLCpkt_Active_Tx_Device_Link_Ref = (t_devicelink *) p_dev_link;
}

/************************************************************************
 * LSLCpkt_Generate_POLL
 *
 * p_dev_link             pointer to active Device Link
 ************************************************************************/
void LSLCpkt_Generate_POLL(t_devicelink *p_dev_link)
{
    _LSLCpkt_Prepare_Piconet_Channel_Access(p_dev_link, TX_START, Connection);
    LSLCacc_Build_PacketHeader(p_dev_link, POLLpkt);
    LSLCpkt_Active_Tx_Device_Link_Ref = (t_devicelink *) p_dev_link;
}

/************************************************************************
 * LSLCpkt_Generate_FHS
 *
 * Each device, local or active maintains its FHS for the piconet.
 *
 * p_dev_link             pointer to active Device Link
 * fhs_context           InquiryResponse or MasterPageResponse
 *
 * Generate Payload Length 144 bits
 *      Parity bits, LAP, Undefined, SR, SP, UAP, NAP,
 *      Class of Device, AM_ADDR, CLK27-2, Page Scan Mode
 *
 *      First 60 bits of payload are the sync word of this device:
 *      Parity bits[34]:        Parity bits of sync word of this device
 *      LAP[24]:                LAP of this device
 *      undefined[2]            For future use
 *      SR[2]                   Page Scan Repetition
 *      SP[2]                   Page Scan Period
 *
 *      UAP[8]                  UAP of this device
 *      NAP[16]                 NAP of this device
 *      Class of Device[24]     Class of device [not defined V0.9]
 *      AM_ADDR[3]              Member address that the recipient shall
 *                              use or is using.
 *      CLK[26]                 Clock[27:2] of this device
 *                              (updated before each send)
 *      PageScanMode[3]         Page scan mode for paging sender.
 *
 *      if (current device is a slave responding to an inquiry)
 *         AM_ADDR = 0
 *      endif
 *      The devlink associated with the sending device must have its
 *      Access Code set to the actual i.e. page/inquiry/channel
 *
 * LSLCpkt_Generate_FHS_Ex() - extended function, takes an explicit
 *     native clk value - used in Master Slave Switch
 *
 * LSLCpkt_Generate_FHS_Common_() - static local function containing
 *     common FHS code between ordinary function and extended
 ************************************************************************/

static void LSLCpkt_Generate_FHS_Common_(t_devicelink *p_dev_link,
    t_state fhs_context);

void LSLCpkt_Generate_FHS(t_devicelink *p_dev_link,
    t_state fhs_context)
{
    LSLCpkt_Generate_FHS_Common_(p_dev_link, fhs_context);

#if (PRH_BS_CFG_SYS_LMP_EXTENDED_INQUIRY_RESPONSE_SUPPORTED==1)
    FHS_Set_EIR(LC_Get_Device_FHS_Ref(), (u_int8)(((fhs_context == InquiryResponse) 
        && (LC_Get_Local_EIR_Length()!=0))?(1):(0)));
#endif

    /*
     * Prepare the Payload always from the local device link for
     *    Inquiry Response and Master Page Response and MSS
     * Also updates CLK field
     */
    LSLCacc_Build_FHS_Payload( DL_Get_Local_Device_Ref());
}

void LSLCpkt_Generate_FHS_Ex(t_devicelink *p_dev_link,
    t_state fhs_context, t_clock native_clk)
{
    LSLCpkt_Generate_FHS_Common_(p_dev_link, fhs_context);

    /*
     * Prepare the Payload always from the local device link for
     *    Inquiry Response and Master Page Response and MSS
     * Also updates CLK field
     */
    LSLCacc_Build_FHS_Payload_Ex( DL_Get_Local_Device_Ref(), native_clk);
}
#endif//BLUETOOTH_MODE_LE_ONLY
#if (PRH_BS_DEV_EARLY_PREPARE_PAGE_ID_FHS_TURNAROUND==1)
void LSLCpkt_Generate_FirstFHS_MasterPageResponse(t_devicelink *p_dev_link)
{
    t_clock base_clk = HW_get_native_clk() + DL_Get_Clock_Offset(p_dev_link);

    LSLCfreq_Prepare_Frequency_FirstFHS_MasterPageResponse(base_clk);

    LSLCacc_Prepare_Tx_Rx_FHS(MasterPageResponse,
        (t_uap) (DL_Get_UAP_LAP(p_dev_link)>>24) /*crc-hec init*/);

    LSLCacc_Build_AccessCode(DL_Get_Access_Syncword_Ref(p_dev_link));
    LSLCacc_Build_PacketHeader(p_dev_link, FHSpkt);
    LSLCpkt_Active_Tx_Device_Link_Ref = (t_devicelink *) p_dev_link;
    LSLCacc_Build_FHS_Payload( DL_Get_Local_Device_Ref());
}
#endif
#ifndef BLUETOOTH_MODE_LE_ONLY
void LSLCpkt_Generate_FHS_Common_(t_devicelink *p_dev_link,
    t_state fhs_context)
{
    /*
     * If (Inquiry Response FHS) Then
     *   BD_ADDR for Inquiry is always GIAC based
     * Else If (Master Page Response FHS) Then
     *   BD_ADDR is Slaves
     * Else If (Slave in Master Slave Switch) Then
     *   BD_ADDR is Masters
     * Endif
     */

    /*
     * Access Code
     *
     * Note p_dev_link->accessSyncword determines whether DAC, IAC, or CAC
     *
     * If (Inquiry Response FHS) Then
     *   Access Code is Inquiry Access Code
     * Else If (Master Page Response FHS) Then
     *   Access Code is Slaves Access Code
     * Else If (Slave in Master Slave Switch) Then
     *   Access Code is Current Piconet CAC
     * Endif
     */

    /*
     * Initialisation of HEC/CRC INIT registers
     *
     * If(Inquiry Response FHS) Then
     *    Use Default Check Initialiser (DCI) for HEC/CRC
     * Else If (Master Page Response FHS) Then
     *    Use Slave UAP for HEC/CRC
     * Else
     *    Use UAP of Master         * Default
     * Endif
     *
     * i.e.  The UAP of the address used for Frequency Hop Calculation
     */

    /*
     * AM_ADDR of Payload  
     *
     * If (current device is a slave responding to a master
     *         or a unit responding to an inquiry) Then
     *    AM_ADDR = 0
     * Endif
     *
     * Will be handled by initialisation of device structure.
     */
    
    /*
     * AM_ADDR of Payload Header
     *
     * If(FHS packet is used for freq hop synchronisation
     *    before piconet channel established) Then
     *    AM_ADDR in payload header = 0
     * Else If (Used for a piconet change (during Master-Slave Switch) Then
     *    AM_ADDR is slaves AM_ADDR
     * Endif
     * Note: AM_ADDR is initialised during Device Link initialisation.
     */


    t_uap_lap freq_crc_uap_lap;
    /*
     * Determine uap_lap for Frequency calculations (UAP used for CRC/HEC init)
     *    Inquiry Response       -> GIAC
     *    Master Page Response   -> Active Device Link
     */
    if (fhs_context==InquiryResponse)
    {
        freq_crc_uap_lap = ((t_uap_lap) DEFAULT_CHECK_INIT)<<24 | GIAC_LAP;
    }
    else
    {
        freq_crc_uap_lap = DL_Get_UAP_LAP(p_dev_link);
    }
#if (PRH_BS_CFG_SYS_LMP_RSSI_SUPPORTED==1)
#if (PRH_BS_CFG_SYS_INQUIRY_RESPONSE_TX_PWR_SUPPORTED == 1)
	if (fhs_context== InquiryResponse)
		HWradio_Set_Tx_Power_Level(g_LM_config_info.inquiry_response_tx_power_level); 
	else
#endif
		HWradio_Set_Tx_Power_Level(DL_Get_Power_Level(p_dev_link)); 
#endif
    LSLCfreq_Prepare_Frequency_Context(p_dev_link, TX_START, fhs_context);

    /*
     * Prepare the transmitter.
     */
    if (Master_Slave_Switch != fhs_context)
    {
        LSLCacc_Prepare_Tx_Rx_FHS(fhs_context,
            (t_uap) (freq_crc_uap_lap>>24) /*crc-hec init*/);
    }
    else
    {
        LSLCacc_Prepare_Tx_Rx_Connection(p_dev_link,
           (t_uap) (freq_crc_uap_lap>>24) /*crc-hec init*/,
           ENCRYPT_NONE,
           fhs_context);
    }

    LSLCacc_Build_AccessCode(DL_Get_Access_Syncword_Ref(p_dev_link));
    LSLCacc_Build_PacketHeader(p_dev_link, FHSpkt);
    LSLCpkt_Active_Tx_Device_Link_Ref = (t_devicelink *) p_dev_link;
}
#endif//BLUETOOTH_MODE_LE_ONLY

#if (PRH_BS_CFG_SYS_LMP_EXTENDED_INQUIRY_RESPONSE_SUPPORTED==1)
/************************************************************************
 * LSLCpkt_Generate_EIR
 * Generate any of the EIR packets
 ************************************************************************/
void LSLCpkt_Generate_EIR(t_devicelink *p_dev_link)
{
    t_uap_lap freq_crc_uap_lap = ((t_uap_lap) DEFAULT_CHECK_INIT)<<24 | GIAC_LAP;
#if (PRH_BS_CFG_SYS_LMP_RSSI_SUPPORTED==1)
#if (PRH_BS_CFG_SYS_INQUIRY_RESPONSE_TX_PWR_SUPPORTED == 1)
    HWradio_Set_Tx_Power_Level(g_LM_config_info.inquiry_response_tx_power_level);
#else
	HWradio_Set_Tx_Power_Level(MAX_POWER_LEVEL_UNITS);
#endif
#endif
    
    LSLCfreq_Prepare_Frequency_Context(p_dev_link, TX_START, InquiryResponse);

    /* EIR preparation of GP1/GP2 same as for IR FHS packets... */
    LSLCacc_Prepare_Tx_Rx_FHS(InquiryResponse,
        (t_uap) (freq_crc_uap_lap>>24) /*crc-hec init*/);

    LSLCacc_Build_AccessCode(DL_Get_Access_Syncword_Ref(p_dev_link));
    DL_Set_Tx_LT_Seqn(p_dev_link,0);
	EIR_Packet=1;
    LSLCacc_Build_PacketHeader(p_dev_link, LC_Get_Local_EIR_Packet_Type());
	EIR_Packet=0;

    LSLCpkt_Active_Tx_Device_Link_Ref = (t_devicelink *) p_dev_link;

    LSLCacc_Build_EIR_Payload();
}
#endif

/************************************************************************
 * LSLCpkt_Generate_ACL
 * Generate any of the ACL packets
 *
 * p_dev_link             pointer to active Device Link
 *
 * Preconditions:
 *    The Tx Descriptor is correctly set up in the device link.
 *    The Tx SEQN is valid.
 *    That there are no length violations.
 ************************************************************************/
#ifndef BLUETOOTH_MODE_LE_ONLY
void LSLCpkt_Generate_ACL(t_devicelink *p_dev_link)
{
    t_packet tx_packet = DL_Get_Tx_Packet_Type(p_dev_link);
#if((LC_DEFERRED_PAYLOAD_EXTRACTION_SUPPORTED==1) || (LC_DEFERRED_LOOPBACK_PAYLOAD_EXTRACTION_SUPPORTED==1))
	u_int8 loopback_ack=0;
#endif

    HWradio_SetRadioMode(RADIO_MODE_TX_RX);

    switch(tx_packet) 
    { 
       case POLLpkt : 
           LSLCpkt_Generate_POLL(p_dev_link); 
           break; 

       case NULLpkt : 
           LSLCpkt_Generate_NULL(p_dev_link); 
           break; 

       default : 
           if (!DL_Get_Remote_Rxbuf_Full(p_dev_link)) 
           { 
                DL_Set_Tx_Ack_Pending(p_dev_link, TRUE); 

                _LSLCpkt_Prepare_Piconet_Channel_Access(p_dev_link, 
                                    TX_START, Connection);
#if (PRH_BS_CFG_SYS_ENHANCED_POWER_CONTROL_SUPPORTED==1)
		        /*
				 * If an EDR packet is to be transmitted and EPC is supported in the peer then
				 * need to override the tx_power_level set in _LSLCpkt_Prepare_Piconet_Channel_Access()
				 */
#if (PRH_BS_CFG_SYS_LMP_RSSI_SUPPORTED==1)
				if (DL_Is_EPC_Enabled(p_dev_link) && is_EDR_ACL_packet(tx_packet))
					HWradio_Set_Tx_Power_Level(DL_Get_EPC_Power_Level(p_dev_link, tx_packet)); 
#endif
#endif
#if ((LC_DEFERRED_PAYLOAD_EXTRACTION_SUPPORTED==1) || (LC_DEFERRED_LOOPBACK_PAYLOAD_EXTRACTION_SUPPORTED==1))
				//if (test mode active & l_ch != LMP_MSG)
				//	Ack the packet of Queue and reset Ack Pending
			    if((BTtst_Get_DUT_Mode() == DUT_ACTIVE_LOOPBACK) &&
					(DL_Get_Tx_Message_Type(p_dev_link) != LMP_msg))
				{
					extern t_packet deferred_pkt_type; /* lslc_access */
					tx_packet = deferred_pkt_type;
					loopback_ack = 1;
				}
#endif
                LSLCacc_Build_PacketHeader(p_dev_link, tx_packet); 
                LSLCacc_Build_ACL_Payload(p_dev_link); 

#if ((LC_DEFERRED_PAYLOAD_EXTRACTION_SUPPORTED==1) || (LC_DEFERRED_LOOPBACK_PAYLOAD_EXTRACTION_SUPPORTED==1))
				if (loopback_ack)
				{
					DL_Set_Local_Tx_L2CAP_Flow(p_dev_link, GO);
					DL_Set_Local_Rx_L2CAP_Flow(p_dev_link, GO);
#if (PRH_BS_DEV_TOGGLE_TX_SEQN_ON_TX_CRC_PACKET ==1)
					DL_Set_Tx_Seqn_Not_Active(p_dev_link);
#endif
					loopback_ack = 0;

				}
#endif
           } 
           else 
           { 
                LSLCpkt_Generate_NULL(p_dev_link); 
           } 
           break; 
    } 

    LSLCpkt_Active_Tx_Device_Link_Ref = (t_devicelink *) p_dev_link;
}
#endif//BLUETOOTH_MODE_LE_ONLY

#if (PRH_BS_CFG_SYS_LMP_SCO_SUPPORTED==1)
/************************************************************************
 * LSLCpkt_Generate_SCO
 *
 * p_dev_link             pointer to active Device Link
 * packet_type            HV1, HV2, HV3
 *
 * Generate any of the SCO packets
 ************************************************************************/
void LSLCpkt_Generate_SCO(t_devicelink *p_dev_link)
{
#ifdef SYS_DEBUG_INSERT_HEC_ON_ESCO_TX
	extern u_int8 eSCO_Active;
#endif
    LSLCpkt_Active_Tx_Device_Link_Ref = (t_devicelink *) p_dev_link;

    if (p_dev_link->active_sco_pkt == DM1 )
    {
        DL_Set_Tx_Ack_Pending(p_dev_link, TRUE);

        LSLCpkt_Generate_ACL(p_dev_link);
#if (PRH_BS_CFG_SYS_SYN_VIA_HCI_SUPPORTED==1)
        /*
         * Where DM1 prioritises over transmission of enqueued SCO, the
         * SCO packet due at this time must be disarded, as otherwise a
         * latency creep would be introduced onto the voice channel.
         */
        LSLCacc_Discard_SCO_Payload(p_dev_link);
#endif
    }
    else if (p_dev_link->active_sco_pkt == DV )
    {

        DL_Set_Tx_Ack_Pending(p_dev_link, TRUE);

        LSLCpkt_Generate_DV(p_dev_link);
    }
	else if (p_dev_link->active_sco_pkt == NULLpkt )
    {
        LSLCpkt_Generate_NULL(p_dev_link);
#if (PRH_BS_CFG_SYS_SYN_VIA_HCI_SUPPORTED==1)
        /*
         * Where DM1 prioritises over transmission of enqueued SCO, the
         * SCO packet due at this time must be disarded, as otherwise a
         * latency creep would be introduced onto the voice channel.
         */
        LSLCacc_Discard_SCO_Payload(p_dev_link);
#endif
	}
    else
    {
#ifdef SYS_DEBUG_INSERT_HEC_ON_ESCO_TX
		 eSCO_count++;
		 if ((eSCO_count==1) || (eSCO_count==2))
		 {
			eSCO_Active = 1;
		 }
		 else if (eSCO_count >= 3)
		 {
			eSCO_Active = 0;
			eSCO_count = 0;
		 }
#endif
        _LSLCpkt_Prepare_Piconet_Channel_Access(p_dev_link, TX_START, Connection);
#ifdef SYS_DEBUG_INSERT_HEC_ON_ESCO_TX
		 eSCO_Active = 0;
#endif

#if 0//(PRH_BS_CFG_SYS_ENHANCED_POWER_CONTROL_SUPPORTED==1)
        /*
		 * If an EDR packet is to be transmitted and EPC is supported in the peer then
		 * need to override the tx_power_level set in _LSLCpkt_Prepare_Piconet_Channel_Access()
		 */
        if (DL_Is_EPC_Enabled(p_dev_link) && is_EDR_ESCO_packet(p_dev_link->active_sco_pkt))
			HWradio_Set_Tx_Power_Level(DL_Get_EPC_Power_Level(p_dev_link, p_dev_link->active_sco_pkt)); 
#endif
#if (PRH_BS_CFG_SYS_LMP_EXTENDED_SCO_SUPPORTED == 1)
        if (is_eSCO_LT(p_dev_link->tx_lt_index))
        {
            t_packet tx_packet = p_dev_link->active_sco_pkt;

            switch(tx_packet) 
            { 
                case POLLpkt : 
                    LSLCpkt_Generate_POLL(p_dev_link); 
                    break; 

                case NULLpkt : 
                    LSLCpkt_Generate_NULL(p_dev_link); 
                    break; 

                default : 
                    DL_Set_Tx_LT_Tx_Ack_Pending(p_dev_link, TRUE);
                    LSLCacc_Build_PacketHeader(p_dev_link, p_dev_link->active_sco_pkt);
                    LSLCacc_Build_SCO_Payload(p_dev_link);
            }
        }
        else
        {
            LSLCacc_Build_PacketHeader(p_dev_link, p_dev_link->active_sco_pkt);
            LSLCacc_Build_SCO_Payload(p_dev_link);
        }
        
#else
        LSLCacc_Build_PacketHeader(p_dev_link, p_dev_link->active_sco_pkt);
        LSLCacc_Build_SCO_Payload(p_dev_link);
#endif

    }
}

/************************************************************************
 * LSLCpkt_Generate_DV
 *
 * p_dev_link             pointer to active Device Link
 * sco_src                Source of SCO
 ************************************************************************/
void LSLCpkt_Generate_DV(t_devicelink *p_dev_link)
{
    LSLCpkt_Active_Tx_Device_Link_Ref = p_dev_link;

    _LSLCpkt_Prepare_Piconet_Channel_Access(p_dev_link, TX_START, Connection);
    DL_Set_Active_Tx_LT(p_dev_link, ACL_SCO_LT);
    LSLCacc_Build_PacketHeader(p_dev_link, DV);

    LSLCacc_Build_ACL_Payload(p_dev_link);
    LSLCacc_Build_SCO_Payload(p_dev_link);
}
#endif

/************************************************************************
 *
 * Transmitter/Receiver Common Functions
 *
 ************************************************************************/


/************************************************************************
 * _LSLCpkt_Prepare_Piconet_Channel_Access
 *
 * Prepares the common part for any packet on a Piconet Channel.
 *
 * p_dev_link             pointer to active Device Link
 * frame_position         Tx or Rx using TX_START | RX_START
 * context                either Connection or Master_Slave_Switch
 *                        (special form of Connection)
 ************************************************************************/
#ifndef BLUETOOTH_MODE_LE_ONLY
static void _LSLCpkt_Prepare_Piconet_Channel_Access(
    const t_devicelink *p_dev_link, t_frame_pos frame_position,
    t_state context)
{
    t_uap_lap freq_crc_uap_lap;
    t_role role_of_peer = DL_Get_Role_Peer(p_dev_link);
    t_encrypt_mode encrypt_mode =DL_Get_Encryption_Mode(p_dev_link);

   /*
    * Actual devicelink also valid if Master (Don't use Ternary here).
    */
    if (role_of_peer==MASTER)
    {
        freq_crc_uap_lap = DL_Get_UAP_LAP(p_dev_link);
    }
    else
    {
        freq_crc_uap_lap = DL_Get_UAP_LAP(DL_Get_Local_Device_Ref());
    }

#if (PRH_BS_CFG_SYS_LMP_RSSI_SUPPORTED==1)
    if(frame_position == TX_START)
    {
        HWradio_Set_Tx_Power_Level(DL_Get_Power_Level(p_dev_link)); 
    }
#endif

    if (context == Connection)
    {
        LSLCfreq_Prepare_Frequency_Connection(p_dev_link, frame_position);
    }
    else
    {
        SYSdebug_Assert(context==Master_Slave_Switch);
        LSLCfreq_Prepare_Frequency_Context(p_dev_link, frame_position, context);
    }

    /*
     * Encryption can be asymmetric Tx Only or Rx Only
     * Following code  maps into hardware for each slot, as requested.
     * #557  Hardware uses 3 for encryption all (not 2!)
     *
     * if context == Master_Slave_Switch,
     *     encrypt_mode must == ENCRYPT_NONE
     */
    if(encrypt_mode == ENCRYPT_POINT2POINT_BROADCAST)
    {
        encrypt_mode = ENCRYPT_HARDWARE_ONLY_ALL;
    }
    else if(encrypt_mode == ENCRYPT_MASTER_RX_ONLY)
    {
         /*
          * Encrypt: Master Rx/ Slave Tx
          */
         if((role_of_peer == SLAVE) ^ (frame_position == TX_START))
         {
             encrypt_mode = ENCRYPT_POINT2POINT;
         }
         else
         {
             encrypt_mode = ENCRYPT_NONE;
         }
    }
    else if(encrypt_mode == ENCRYPT_MASTER_TX_ONLY)
    {
         /*
          * Encrypt: Master Tx/ Slave Rx
          */
         if((role_of_peer == SLAVE) ^ (frame_position == TX_START))
         {
             encrypt_mode = ENCRYPT_NONE;
         }
         else
         {
             encrypt_mode = ENCRYPT_POINT2POINT;
         }
    }


    if (encrypt_mode != ENCRYPT_NONE)
    {
        LSLCacc_Prepare_Tx_Rx_Encryption(DL_Get_Encryption_Key_Ref(p_dev_link),
                                     DL_Get_Encryption_Key_Length(p_dev_link));
    }

    LSLCacc_Prepare_Tx_Rx_Connection(p_dev_link,
       (t_uap) (freq_crc_uap_lap>>24) /*crc-hec init*/,
       encrypt_mode,
       context);

    LSLCacc_Build_AccessCode(DL_Get_Access_Syncword_Ref(p_dev_link));
}
#endif//BLUETOOTH_MODE_LE_ONLY
/************************************************************************
 * LSLCpkt_Get_Active_Rx_Device_Link_Ref
 *
 * Returns a reference to the Active Receive Device Link
 ************************************************************************/
t_devicelink* LSLCpkt_Get_Active_Rx_Device_Link_Ref(void)
{
    return LSLCpkt_Active_Rx_Device_Link_Ref;
}

/************************************************************************
 * LSLCpkt_Get_Active_Tx_Device_Link_Ref
 *
 * Returns a reference to the Active Transmit Device Link
 ************************************************************************/
t_devicelink* LSLCpkt_Get_Active_Tx_Device_Link_Ref(void)
{
    return LSLCpkt_Active_Tx_Device_Link_Ref;
}
